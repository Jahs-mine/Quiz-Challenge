// spelling.js
class Bee {
  static lexicon = [
    {
      difficulty: "easy",
      data: {
        kings: [
          "Saul",
          "David",
          "Solomon",
          "Rehoboam",
          "Asa",
          "Jehoshaphat",
          "Ahab",
          "Uzziah",
          "Joash",
          "Josiah",
          "Hezekiah",
          "Jeroboam",
          "Abijah",
          "Manasseh",
          "Jehu",
          "Zedekiah",
          "Jehoiakim",
          "Jehoiachin",
          "Omri",
          "Nadab",
        ],
        queens: [
          "Queen of Sheba",
          "Esther",
          "Vashti",
          "Bathsheba",
          "Jezebel",
          "Athaliah",
          "Maacah",
          "Michal",
          "Abigail",
        ],
        prophets: [
          "Elijah",
          "Samuel",
          "Isaiah",
          "Jeremiah",
          "Ezekiel",
          "Daniel",
          "Hosea",
          "Joel",
          "Amos",
          "Micah",
          "Nathan",
          "Gad",
          "Obadiah",
          "Jonah",
          "Nahum",
          "Habakkuk",
          "Zephaniah",
          "Haggai",
          "Zechariah",
          "Malachi",
        ],
        places: [
          "Jerusalem",
          "Bethlehem",
          "Nazareth",
          "Egypt",
          "Eden",
          "Jericho",
          "Zion",
          "Galilee",
          "Canaan",
          "Judea",
          "Samaria",
          "Philippi",
          "Sinai",
          "Corinth",
          "Damascus",
          "Babylon",
          "Golgotha",
          "Bethany",
          "Gilgal",
          "Sodom",
          "Capernaum",
          "Thessalonica",
          "Ephesus",
          "Hebron",
          "Gilead",
          "Assyria",
          "Antioch",
          "Emmaus",
          "Gomorrah",
          "Persia",
          "Joppa",
          "Tyre",
          "Sidon",
          "Caesarea",
          "Ptolemais",
        ],
        rivers: [
          "Jordan",
          "Nile",
          "Euphrates",
          "Tigris",
          "Arnon",
          "Jabbok",
          "Kidron",
          "Sihon",
        ],
        animals: [
          "Sheep",
          "Goat",
          "Donkey",
          "Lion",
          "Bear",
          "Wolf",
          "Ox",
          "Dove",
          "Fish",
          "Camel",
          "Cow",
          "Horse",
          "Dog",
          "Cat",
          "Fox",
          "Hyena",
          "Leopard",
          "Cheetah",
          "Elephant",
          "Hippopotamus",
          "Rhinoceros",
          "Giraffe",
          "Zebra",
          "Gazelle",
          "Antelope",
          "Deer",
          "Monkey",
          "Ape",
          "Rabbit",
          "Hare",
          "Squirrel",
          "Mouse",
          "Rat",
          "Bat",
          "Bird",
          "Snake",
          "Lizard",
          "Crocodile",
          "Insect",
          "Spider",
          "Scorpion",
        ],
      },
    },
    {
      difficulty: "medium",
      data: {
        kings: [
          "Hezekiah",
          "Josiah",
          "Jehoahaz",
          "Amaziah",
          "Adonijah",
          "Pekah",
          "Menahem",
          "Ahaz",
          "Jehoiada",
          "Jehoram",
          "Jehoiakim",
          "Jeconiah",
          "Zedekiah",
          "Ahab",
          "Jehu",
          "Hoshea",
        ],
        queens: [
          "Esther",
          "Athaliah",
          "Vashti",
          "Jezebel",
          "Tirzah",
          "Jedidah",
          "Azubah",
          "Shulamite Woman",
          "Ahinoam",
          "Shelomith",
          "Michal",
          "Maacah",
        ],
        prophets: [
          "Isaiah",
          "Jeremiah",
          "Ezekiel",
          "Habakkuk",
          "Zephaniah",
          "Malachi",
          "Obadiah",
          "Zechariah",
          "Nahum",
          "Haggai",
          "Daniel",
          "Hosea",
          "Joel",
          "Amos",
          "Jonah",
          "Micah",
          "Elisha",
        ],
        places: [
          "Capernaum",
          "Thessalonica",
          "Babylon",
          "Ephesus",
          "Damascus",
          "Bethany",
          "Antioch",
          "Gilead",
          "Hebron",
          "Nineveh",
          "Ararat",
          "Sidon",
          "Tyre",
          "Laodicea",
          "Beersheba",
          "Shiloh",
          "Penuel",
          "Gilgal",
          "Nazareth",
          "Sinai",
          "Philippi",
          "Samaria",
          "Colosse",
          "Pella",
          "Gerasa",
          "Philadelphia",
          "Pergamum",
          "Sardis",
          "Laodicea",
        ],
        rivers: [
          "Euphrates",
          "Tigris",
          "Jabbok",
          "Kidron",
          "Pishon",
          "Gihon",
          "Hiddekel",
          "Chebar",
        ],
        animals: [
          "Leopard",
          "Hyena",
          "Eagle",
          "Vulture",
          "Serpent",
          "Jackal",
          "Ram",
          "Hart",
          "Gazelle",
          "Locust",
          "Lion",
          "Bear",
          "Wolf",
          "Cheetah",
          "Fox",
          "Badger",
          "Weasel",
          "Mongoose",
          "Wild Boar",
          "Antelope",
          "Deer",
          "Ibex",
          "Hare",
          "Rabbit",
          "Squirrel",
          "Mouse",
          "Rat",
          "Bat",
          "Eagle",
          "Hawk",
          "Owl",
          "Dove",
          "Pigeon",
          "Quail",
          "Partridge",
          "Ostrich",
          "Peacock",
          "Crane",
          "Stork",
          "Swallow",
          "Sparrow",
          "Raven",
          "Crow",
          "Snake",
          "Lizard",
          "Crocodile",
          "Turtle",
          "Tortoise",
          "Frog",
          "Toad",
          "Fish",
          "Shark",
          "Whale",
          "Dolphin",
          "Insect",
          "Spider",
          "Scorpion",
          "Worm",
        ],
      },
    },
    {
      difficulty: "hard",
      data: {
        kings: [
          "Manasseh",
          "Zedekiah",
          "Shalmaneser",
          "Tiglath-Pileser",
          "Sennacherib",
          "Esarhaddon",
          "Belshazzar",
          "Cyrus",
          "Darius",
          "Artaxerxes",
          "Ahaz",
          "Jotham",
          "Amaziah",
          "Azariah",
          "Uzziah",
          "Joram",
        ],
        queens: [
          "Athaliah",
          "Maacah",
          "Taphath",
          "Basemath",
          "Keturah",
          "Shiphrah",
          "Puah",
          "Tryphena",
          "Tryphosa",
          "Bernice",
          "Jezebel",
          "Huldah",
        ],
        prophets: [
          "Hosea",
          "Zephaniah",
          "Habakkuk",
          "Obadiah",
          "Nahum",
          "Malachi",
          "Micah",
          "Haggai",
          "Zechariah",
          "Joel",
          "Jeremiah",
          "Ezekiel",
          "Daniel",
          "Elisha",
          "Elijah",
        ],
        places: [
          "Assyria",
          "Gomorrah",
          "Gilead",
          "Perea",
          "Sodom",
          "Tarshish",
          "Ur",
          "Patmos",
          "Ammon",
          "Moab",
          "Mizraim",
          "Dedan",
          "Ezion-Geber",
          "Kadesh",
          "Bashan",
          "Shechem",
          "Ashkelon",
          "Zarephath",
          "Aram",
          "Sidon",
          "Hebron",
          "Antioch",
          "Emmaus",
          "Persia",
          "Ararat",
          "Nineveh",
          "Haran",
          "Carchemish",
          "Hamath",
          "Tyre",
          "Byblos",
          "Berytus",
          "Damascus",
          "Palmyra",
          "Petra",
          "Alexandria",
          "Ephesus",
          "Smyrna",
          "Pergamum",
          "Thyatira",
          "Sardis",
          "Philadelphia",
          "Laodicea",
        ],
        rivers: [
          "Jabbok",
          "Sihon",
          "Chebar",
          "Hiddekel",
          "Shihor",
          "Ahava",
          "Abana",
          "Pharpar",
          "Ulai",
          "Great River",
        ],
        animals: [
          "Behemoth",
          "Leviathan",
          "Cockatrice",
          "Chameleon",
          "Viper",
          "Adder",
          "Ibex",
          "Unicorn",
          "Ostrich",
        ],
      },
    },
  ];
  constructor(mode, categories, wordsPerRound = 3) {
    this.synth = window.speechSynthesis;
    this.reStartButton = document.getElementById("reStart");
    this.reveal = document.getElementById("reveal");
    this.speaker = document.getElementById("speaker");
    this.spelling = document.getElementById("spelling");
    this.submitButton = document.getElementById("submit");
    this.nextButton = document.getElementById("next");
    this.status = document.getElementById("status");
    this.innerBar = document.getElementById("inner_bar");

    this.mode = mode;
    this.categories = categories.length > 0 ? categories : ["kings"];
    this.wordsPerRound = wordsPerRound;
    this.words = this.getWordsForRound(this.mode, this.categories);
    this.currentWordIndex = 0;
    this.roundActive = false;

    this.reveal.disabled = true;
    this.submitButton.disabled = false;
    this.nextButton.disabled = true;

    this.reveal.style.display = "none"; // Initially hidden
    this.nextButton.style.display = "none"; // Initially hidden
    this.submitButton.style.display = "inline-block"; // Initially visible

    this.reStartButton.addEventListener("click", this.reStart.bind(this));
    this.reveal.addEventListener("click", this.revealSpelling.bind(this));
    this.speaker.addEventListener("click", this.handleSpeaker.bind(this));
    this.submitButton.addEventListener("click", this.handleSubmit.bind(this));
    this.nextButton.addEventListener("click", this.nextWord.bind(this));
    this.spelling.addEventListener("keyup", this.handleInput.bind(this));
    this.startRound();
  }

  handleSpeaker() {
    if (!this.submitButton.disabled) {
      console.log(this.submitButton.disabled);
      this.reveal.disabled = false;
      this.reveal.style.display = "inline-block";
    }
    this.speakWord();
  }

  handleSubmit() {
    this.submitSpelling();
  }

  nextWord() {
    if (!this.roundActive) return;

    if (this.currentWordIndex <this.words.length ) {
      this.currentWordIndex++;
      this.spelling.value = "";
      this.status.innerHTML = "";
      this.reveal.style.display = "none"; // Hide Reveal
      this.nextButton.style.display = "none"; // Hide Next
      if (this.currentWordIndex <= this.words.length - 1) {
        this.submitButton.style.display = "inline-block"; // Show Submit
        this.submitButton.disabled = false;
      }

      this.handleSpeaker();
      this.setProgress((this.currentWordIndex / this.words.length) * 100);
      this.reveal.disabled = true;

      this.nextButton.disabled = true;
    } else {
      this.endRound();
    }
  }

  loadProgress() {
    const progress = JSON.parse(localStorage.getItem("spellingProgress")) || {};
    return progress;
  }

  saveProgress(word, correct, incorrect) {
    let progress = this.loadProgress();

    if (!progress[word] && (correct || incorrect)) {
      progress[word] = { correct: 0, incorrect: 0 };
    }
    if (progress[word]) {
      progress[word].correct += correct ? 1 : 0;
      progress[word].incorrect += incorrect ? 1 : 0;
    }

    localStorage.setItem("spellingProgress", JSON.stringify(progress));
    this.checkProgressReset();
  }

  checkProgressReset() {
    const lastReset = localStorage.getItem("lastProgressReset");
    const now = Date.now();
    const RESET_INTERVAL = 7 * 24 * 60 * 60 * 1000;

    if (!lastReset || now - lastReset > RESET_INTERVAL) {
      localStorage.removeItem("spellingProgress");
      localStorage.setItem("lastProgressReset", now);
    }
  }

  getWordsForRound(mode, categories) {
    let words = [];

    if (mode === "3") {
      Bee.lexicon.forEach((level) => {
        categories.forEach((category) => {
          words = words.concat(
            this.getRandomWords(level.difficulty, category, this.wordsPerRound)
          );
        });
      });
    } else {
      const difficulties = ["easy", "medium", "hard"];
      const difficulty = difficulties[parseInt(mode, 10)];
      categories.forEach((category) => {
        words = words.concat(
          this.getRandomWords(difficulty, category, this.wordsPerRound)
        );
      });
    }

    return this.shuffleArray(words);
  }

  getRandomWords(difficulty, category, count) {
    const difficultyLower = difficulty.toLowerCase().trim();
    const categoryLower = category.toLowerCase().trim();

    const entry = Bee.lexicon.find(
      (level) => level.difficulty.toLowerCase().trim() === difficultyLower
    );

    if (!entry) {
      console.warn(`Invalid difficulty "${difficulty}" was not found.`);
      return [];
    }

    if (!entry.data[categoryLower]) {
      console.warn(
        `Invalid category "<span class="math-inline">\{category\}" for difficulty "</span>{difficulty}".`
      );
      return [];
    }

    let availableWords = [...entry.data[categoryLower]];
    const progressData = this.loadProgress();
    const selectedWords = [];

    const weightedWords = [];
    availableWords.forEach((word) => {
      const progress = progressData[word] || { correct: 0, incorrect: 0 };
      let weight = 1;

      if (Object.keys(progressData).length !== 0 && progress) {
        weight =
          1 / (Math.sqrt(progress.correct + 1) * (progress.incorrect + 1));
      }
      weightedWords.push({ word, weight });
    });

    weightedWords.sort((a, b) => b.weight - a.weight);

    const numToSelect = Math.min(count, weightedWords.length);
    for (let i = 0; i < numToSelect; i++) {
      selectedWords.push(weightedWords[i].word);
    }

    return selectedWords;
  }

  shuffleArray(array) {
    for (let i = array.length - 1; i > 0; i--) {
      const j = Math.floor(Math.random() * (i + 1));
      [array[i], array[j]] = [array[j], array[i]];
    }
    return array;
  }

  speakWord() {
    if (
      this.words.length > 0 &&
      this.currentWordIndex < this.words.length &&
      this.roundActive
    ) {
      const wordToSpeak = this.words[this.currentWordIndex];
      this.speaker.disabled = true;
      this.status.setAttribute("aria-live", "polite");

      try {
        this.speak(wordToSpeak);
      } catch (error) {
        console.error("Error speaking word:", error);
      } finally {
        this.speaker.disabled = false;
      }
    } else if (!this.roundActive) {
      return; // Don't speak if round is inactive
    } else {
      this.status.innerHTML = `<span class="game-message game-message-error">You've finished all words!</span>`;
    }
  }

  async speak(text) {
    return new Promise((resolve, reject) => {
      if (this.synth.speaking) {
        this.synth.onvoiceschanged = () => {
          this.speak(text).then(resolve).catch(reject);
          this.synth.onvoiceschanged = null;
        };
        return;
      }

      const utterance = new SpeechSynthesisUtterance(text);

      utterance.onend = () => {
        this.spelling.focus();
        resolve();
      };

      utterance.onerror = (event) => {
        console.error("Speech error:", event.error);
        reject(event.error);
      };

      this.synth.speak(utterance);
    });
  }

  revealSpelling() {
    if (!this.roundActive) return;
    const correctWord = this.words[this.currentWordIndex];
    this.status.innerHTML = `<span class="game-message game-message-correct">The word was "${correctWord}". Click "Next" for the next word.</span>`;
    this.nextButton.style.display = "inline-block"; // Show Next
    this.nextButton.disabled = false;
    this.saveProgress(correctWord, false, true);
    this.reveal.disabled = true;
    this.reveal.style.display = "none"; // Hide Reveal after use
  }
  startRound() {
    this.roundActive = true;
    this.words = this.getWordsForRound(this.mode, this.categories);
    this.currentWordIndex = 0;
    this.spelling.value = "";
    this.status.innerHTML = "";
    this.reveal.style.display = "none";
    this.nextButton.style.display = "none";
    this.setProgress(0);
    this.reveal.style.display = "none"; // Hide Reveal
    this.nextButton.style.display = "none"; // Hide Next
    this.submitButton.style.display = "inline-block"; // Show Submit
    this.reveal.disabled = true;
    this.submitButton.disabled = false;
    this.nextButton.disabled = true;
    if (this.words.length === 0) {
      this.status.innerHTML = `<span class="game-message game-message-error">No words found for this selection.</span>`;
      this.roundActive = false;
      return;
    }
    this.speakWord();
  }

  handleInput(event) {
    if (event.key === "Enter" && !this.submitButton.disabled) {
      this.handleSubmit();
    }
  }

  submitSpelling() {
    if (!this.roundActive) return;

    if (this.words.length === 0) {
      this.status.innerHTML = `<span class="game-message game-message-error">No words loaded! Select a mode and category.</span>`;
      this.reveal.style.display = "none";
      this.reveal.disabled = "true";
      return;
    }
    if (this.currentWordIndex >= this.words.length) {
      this.reveal.style.display = "none";
      this.reveal.disabled = "true";
      this.status.innerHTML = `<span class="game-message game-message-error">You've finished all words!</span>`;
      return;
    }

    const userInput = this.spelling.value.trim();
    const correctWord = this.words[this.currentWordIndex];

    if (userInput === "") {
      this.status.innerHTML = `<span class="game-message game-message-error">Please attempt spelling before clicking "Submit".</span>`;
      this.reveal.style.display = "none";
      this.reveal.disabled = "true";
      return;
    }

    this.reveal.disabled = true;
    this.reveal.style.display = "none";
    this.submitButton.style.display = "none"; // Hide Submit after click
    this.submitButton.disabled = true; // Hide Submit after click

    if (userInput.toLowerCase() === correctWord.toLowerCase()) {
      this.status.innerHTML = `<span class="game-message game-message-correct">‚úÖ Correct! The word was "${correctWord}".</span>`;
      this.saveProgress(correctWord, true, false);
    } else {
      this.status.innerHTML = `<span class="game-message game-message-incorrect">‚ùå Incorrect. The word was "${correctWord}".</span>`;
      this.nextButton.style.display = "inline-block"; // Show Next
      this.nextButton.disabled = false;
      this.saveProgress(correctWord, false, true);
    }
    if (this.currentWordIndex <= this.words.length - 1) {
      this.nextButton.style.display = "inline-block"; // Show Next
      this.nextButton.disabled = false; // Enable next after submit
    } else {
      this.endRound();
    }
  }

  endRound() {
    this.roundActive = false;
    this.nextButton.style.display = "none"; // Hide Next
    this.reveal.style.display = "none"; // Hide Reveal
    this.submitButton.style.display = "none"; // Show Submit
    this.status.innerHTML = `<span class="game-message game-message-complete">üéâ You've completed all words! Restart to play again.</span>`;
    this.reveal.disabled = true;
    this.submitButton.disabled = true;
    this.nextButton.disabled = true;
  }

  setProgress(percentage) {
    this.innerBar.style.setProperty("--progress-percentage", percentage + "%");
  }

  reStart() {
    this.startRound();
  }
}

document.addEventListener("DOMContentLoaded", () => {
  function getSelectedMode() {
    const selectedRadio = document.querySelector(`input[name="mode"]:checked`);
    return selectedRadio ? selectedRadio.value : "0";
  }

  function getSelectedCategories() {
    return [...document.querySelectorAll('input[name="category"]:checked')].map(
      (checkbox) => checkbox.value
    );
  }

  const wordsPerRound = this.wordsPerRound;
  let mode = getSelectedMode();
  let categories = getSelectedCategories();
  const bee = new Bee(mode, categories, wordsPerRound);
  bee.checkProgressReset();

  document.querySelectorAll('input[name="mode"]').forEach((radio) => {
    radio.addEventListener("change", () => {
      bee.mode = getSelectedMode();
      bee.startRound();
    });
  });

  document.querySelectorAll('input[name="category"]').forEach((checkbox) => {
    checkbox.addEventListener("change", () => {
      bee.categories = getSelectedCategories();
      bee.startRound();
    });
  });
});
